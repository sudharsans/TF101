
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="keywords" content="devops,terraform" />
    <meta name="description" content="Introduction to Terraform" />
    <title>Introduction to Terraform</title>
    <style>
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .small-img img { width: 250px; height: 320px; }
      .otto-img img { width: 640px; height: 226px; }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 6em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .green { color: green; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: red;
      }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
      .strikethrough {
        text-decoration:line-through;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
name: inverse
layout: true
class: center, middle, inverse
---
# Introduction to Terraform
---
.left-column[
  ## My Experience with Terraform
]
.right-column[
I have been using Terraform for the last 5 months.

Terraform is used to create/configure/provision

- VPC, Security groups, route tables

- EC2 instances

- S3 buckets

- ELBs and Auto-scaling groups

- Route53 zones and records

- IAM roles and policies

- CloudWatch alarms

- SNS topics and subscriptions

- AWS Lambda functions
]
---
.left-column[
  ## My Experience with Terraform
  ## What is Terraform?
]
.right-column[
# "Infrastructure as Code"

> Infrastructure as code is the approach to defining computing and network infrastructure through source code that can then be treated just like any software system.

[http://martinfowler.com/bliki/InfrastructureAsCode.html](http://martinfowler.com/bliki/InfrastructureAsCode.html)

Terraform allows you to create, change (and destroy) your infrastructure.

Terraform uses a configuration DSL to describe and version your infrastructure as code.

Terraform is .strikethrough[cloud-agnostic] multi-cloud aware. Supports IaaS (e.g. AWS, DigitalOcean, GCE, OpenStack), PaaS (e.g. Heroku, CloudFoundry), or SaaS services (e.g. DNSimple, CloudFlare)
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
]
.right-column[
Terraform is writting with golang and runs on all major platforms.

Terraform is essentially a set of binaries.

```bash
± |master ✓| → tree ./
./
├── terraform
├── terraform-provider-atlas
├── terraform-provider-aws
├── terraform-provider-azure
├── terraform-provider-azurerm
├── terraform-provider-chef
├── terraform-provider-cloudflare
├── terraform-provider-cloudstack
├── terraform-provider-consul
├── terraform-provider-digitalocean
...
```
Installation is usually about downloading the official release archive, and adding terraform to your path.

Homebrew Cask users can do `brew install terraform`.
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
## HCL and *.tf files

Terraform configuration is written in `*.tf` files.

It is based on the HashiCorp Configuration Language (HCL) [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)

JSON is supported for code generation purposes.

Most of the configuration takes the form:

```
keyword1 "some_name" {
  key = value
  nested {
    key = value
  }
}
```

]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
## Providers
The first thing to do is add one or more `providers`.

Providers are the abstraction over the APIs needed to create our infrastructure in different platforms.

For example, the `aws` provider can be configured as follows:

```
provider "aws" {
  access_key = "ACCESS_KEY_HERE"
  secret_key = "SECRET_KEY_HERE"
  region = "eu-west-1"
}
```
This sets up Terraform to start creating resources in AWS. The credentials and region are required.

In this case, these parameters can alternatively be passed via `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY` and `AWS_DEFAULT_REGION` environment variables.
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
## Resources

Once one or more providers is configured, we can start using resources.

With the AWS provider setup, we can start creating AWS resources like `EC2 instances`, `S3 buckets`, `VPCs` and more.

The following snippet creates an EC2 instance:

```
resource "aws_instance" "example" {
  ami = "ami-408c7f28"
  instance_type = "t1.micro"
}
```
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
## Planning phase
Once we have our configuration ready, we can see what it would end up doing by running `terraform plan`.

The command will "plan" for what needs to be done to our infrastructure, based on the configuration we have written.

It will give detailed report about which resources will be created, deleted and modified.

It is recommended to save the plan using the `-out` argument and specifying the path to write a plan file:

```bash
terraform plan -out=plan1
```

This plan file can then be reliably used to ensure that you apply the steps that were actually planned.
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
## Apply phase
When we are happy with the plan, we can actually go ahead and apply the changes using:

```
terraform apply
```

We can also use a plan generated from a plan command:
```
terraform apply plan1
```

Plan and apply can also target particular resource(s) using the `-target` flag.
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
## Destroy!
We can, if we want to, destroy the entire infrastructure using

```
terraform destroy
```
By, default, this will ask for a confirmation `yes`. This can be avoided by using the `-force` flag.

The plan -> apply -> destroy cycle is useful when you are trying out things. We can also destroy particular resources using the `-target` flag.

Due to the state and configuration file, deleting/destroying a resource is as simple as removing that resource from `.tf` file.
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
## Variables
In the simple examples, we saw values like the AWS region, EC2 AMI, instance type, etc in the configuration itself.

It is ideal to extract out these into variables that we can easily reuse and override if needed.

We can define a few variables in a `variables.tf` file like below:

```
variable "region" {
  default = "eu-west-1"
}

variable "ami" {}

variable "instance_type" {
  description = "Instance type for our dummy instance"
}

```
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
## Assigning/Overriding Variables
Variables without default values have to be assigned them.

Terraform will prompt for these values, if they have not been assigned already, during plan/apply.

Variables with default values can also be overriden.

 - One way to assign/override variables is to use the `-var 'instance_type=t1.micro'` argument to `terraform plan` and `terraform apply`.

 - A `terraform.tfvars` file can be created to hold variables values
   ```
   ami="ami-1208b761"
   instance_type="t1.micro"
   ```
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
## Output Variables
We can also create variables that hold values dynamically generated as part of creating our infrastructure.

For example, we can create an output variable for the ip of an instance:

```
output "ip" {
  value = "${aws_instance.instance.private_ip}"
}
```

We can query output variables using `terraform output` or `terraform output ip`.

Output variables are useful in integrating terraform into rest of your tooling like scripts.
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
## Provisioners
Terraform can also integrate with provisioners like Chef (out of the box), Ansible, shell scripts etc.

One way of doing this is to use the `provisioner` block. The following creates an EC2 instance and installs Nginx in it:

```
resource "aws_instance" "instance" {
  ami = "${var.ami}"
  instance_type = "${var.instance_type}"
  associate_public_ip_address = true
  key_name = "${aws_key_pair.demo.id}"
  subnet_id = "${var.subnet_id}"

  provisioner "remote-exec" {
    inline = [
      "sudo apt-get -y update",
      "sudo apt-get -y install nginx",
      "sudo service nginx start"
    ]

    connection {
      user = "ubuntu"
      private_key = "${file(var.private_key_path)}"
    }
  }
}
```
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
]
.right-column[
  Other Topics:

  ### Templates
  ### Modules
  ### Infrastructure graph
]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
  ### - Pros and cons
]
.right-column[
## Pros
The state management and configuration language of Terraform is very good.

Great for evolving an infrastructure, especially when you are not sure how the final infra will look like.

Active community. Frequent releases.

Does one thing - provision infrastructure - and that one thing well.

Pretty fast, small learning curve.

Encourages immutable infrastructure.

]
---
.left-column[
  ## Terraform Basics
  ### - Installation
  ### - Terraform Configuration
  ### - Pros and cons
]
.right-column[
## Cons

Cannot import existing infra and start managing in a straightforward way. (third party tool exists)

Too strict with regard to immutability.

Some weirdness in the configuration language. eg. - can't pass map variables to modules.

Refactoring into modules is tricky when infra is already created.

Renaming resources is not possible without delete and create.

Sometimes you will endup manipulating your tfstate.

Doesn't replace configration management tools like Ansible. Ansible can do what Terraform does.
]
---
name: last-page
template: inverse

## Happy automating!

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    <script>
      var hljs = remark.highlighter.engine;
    </script>
    <script src="remark.language.js"></script>
    <script>
      var slideshow = remark.create({
          highlightStyle: 'monokai',
          highlightLanguage: 'remark',
          highlightLines: true
        }) ;
    </script>
  </body>
</html>
